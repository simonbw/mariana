#!/usr/bin/env node

/*
 * Generates .d.ts files for all of our assets to provide stricter type
 * checking and nicer autocomplete when importing them.
 */

const yargs = require("yargs");
const glob = require("glob");
const fs = require("fs");
const path = require("path");
const camelcase = require("camelcase");

// mapping extensions to their variable prefix
const extensionToPrefix = {
  // images
  bmp: "img",
  gif: "img",
  jpg: "img",
  png: "img",
  svg: "img",
  // fonts
  ttf: "fnt",
  // audio
  flac: "snd",
  mp3: "snd",
  ogg: "snd",
  wav: "snd",
  // shaders
  frag: "frag",
  vert: "vert",
  //models
  gltf: "gltf",
  glb: "glb",
  //misc
  txt: "txt",
};

const extensions = Object.keys(extensionToPrefix);
const extensionPattern = extensions.join("|");

function log(...args) {
  // Just so this stops showing up in searches for console dot log
  console["log"](...args);
}

// The contents of the generated file
function getContent(fileName) {
  const parts = path.basename(fileName).split(".");
  const baseVarName = camelcase(parts[0]);

  // the extension before the .d.ts
  const extension = parts.length > 3 ? parts[parts.length - 3] : "";
  const prefix = getVariablePrefixFromExtension(extension);

  const varName = `${prefix}_${baseVarName}`;

  return `// This file autogenerated by generate-asset-types.js
declare const ${varName}: string;
export default ${varName};
  `;
}

function getVariablePrefixFromExtension(extension) {
  if (extension in extensionToPrefix) {
    return extensionToPrefix[extension];
  } else {
    console.log("unknown extension", extension);
    return "res";
  }
}

// Removes old types
function cleanTypes(assetsFolder, silent = false) {
  if (!silent) {
    log(`removing old asset .d.ts files from "${assetsFolder}" . . .`);
  }
  const pattern = `${assetsFolder}/**/*.@(${extensionPattern}).d.ts`;
  const fileNames = glob.sync(pattern, {});
  fileNames.forEach((fileName) => {
    if (!silent) {
      log(" - removed " + fileName);
    }
    fs.unlinkSync(fileName);
  });
  if (fileNames.length === 0 && !silent) {
    log("No files to remove");
  }
  return fileNames;
}

// Generates the new type files
function generateTypes(assetsFolder, silent = false) {
  if (!silent) {
    log(`generating new asset .d.ts files in "${assetsFolder}" . . .`);
  }
  const pattern = `${assetsFolder}/**/*.@(${extensionPattern})`;
  const fileNames = glob.sync(pattern, {}).map((f) => f + ".d.ts");
  fileNames.forEach((fileName) => {
    fs.writeFileSync(fileName, getContent(fileName));
    if (!silent) {
      log(" - created " + fileName);
    }
  });
  if (fileNames.length === 0 && !silent) {
    log("No files to generate");
  }

  generateManifest(assetsFolder);

  return fileNames;
}

function generateManifest(assetsFolder, silent = false) {
  const pattern = `${assetsFolder}/**/*.@(${extensionPattern})`;
  const fileNames = glob.sync(pattern, {}).map((f) => f);

  const soundFiles = [];
  const imageFiles = [];

  for (const fileName of fileNames) {
    const parts = fileName.split(".");
    const extension = parts.length > 1 ? parts[parts.length - 1] : "";
    const prefix = getVariablePrefixFromExtension(extension);

    const relativePath = `./${path.relative(assetsFolder, fileName)}`;
    if (prefix === "snd") {
      soundFiles.push(relativePath);
    } else if (prefix === "img") {
      imageFiles.push(relativePath);
    }
  }

  if (soundFiles.length > 0 || imageFiles.length > 0) {
    const content = `// This file autogenerated by generate-asset-types.js
    
    export const ALL_SOUNDS: string[] = [
      ${soundFiles.map((p) => `  require("${p}"),`).join("\n")}
    ];
    
    export const ALL_IMAGES: string[] = [
      ${imageFiles.map((p) => `  require("${p}"),`).join("\n")}
    ];
    `;
    const manifestFile = `${assetsFolder}/assets.ts`;
    fs.writeFileSync(manifestFile, content);

    if (!silent) {
      log(`  Manifest at ${manifestFile}`);
    }
  } else {
    if (!silent) {
      log(`  Manifest skipped because no assets`);
    }
  }
}

function cleanAndGenerate(assetsFolder) {
  log(`Updating asset types in "${assetsFolder}" . . .`);
  const removed = new Set(cleanTypes(assetsFolder, true));
  const generated = new Set(generateTypes(assetsFolder, true));
  const newFiles = [];
  const deletedFiles = [];
  for (const fileName of removed) {
    if (!generated.has(fileName)) {
      deletedFiles.push(fileName);
    }
  }
  for (const fileName of generated) {
    if (!removed.has(fileName)) {
      newFiles.push(fileName);
    }
  }
  if (deletedFiles.length) {
    log(deletedFiles.map((f) => ` - removed ${f}`).join("\n"));
  }
  if (newFiles.length) {
    log(newFiles.map((f) => ` - created ${f}`).join("\n"));
  }
  if (newFiles.length === 0 && deletedFiles.length === 0) {
    log("  Nothing has changed");
  }
  log("");
}

yargs
  .scriptName("generate-asset-types")
  .usage(
    "Generates .d.ts files for assets to provide stricter type checking and nicer autocomplete when importing them."
  )
  .help()
  .option("directory", {
    alias: "d",
    describe: "Directory containing assets",
    default: "./src/assets",
    coerce: (d) => path.resolve(d),
    type: "string",
    normalize: true,
    global: true,
  })
  .command(
    "$0",
    "cleans and generates",
    () => {},
    (argv) => {
      cleanAndGenerate(argv.directory);
    }
  )
  .command(
    "clean",
    "removes all asset types",
    () => {},
    (argv) => {
      cleanTypes(argv.directory);
    }
  )
  .command(
    "generate",
    "generates new .d.ts files",
    () => {},
    (argv) => {
      generateTypes(argv.directory);
    }
  )
  .command("manifest", "creates a manifest of files").argv;
